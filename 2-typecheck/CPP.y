/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the cpp_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE cpp__scan_string(const char *str, yyscan_t scanner);
extern void cpp__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void cpp_lex_destroy(yyscan_t scanner);
extern char* cpp_get_text(yyscan_t scanner);

extern yyscan_t cpp__initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Program* program_;
  Def* def_;
  ListDef* listdef_;
  Field* field_;
  ListField* listfield_;
  Arg* arg_;
  ListArg* listarg_;
  Stm* stm_;
  ListStm* liststm_;
  IdIn* idin_;
  ListIdIn* listidin_;
  Exp* exp_;
  ListExp* listexp_;
  Type* type_;
  ListId* listid_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, cpp_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANGEQ     /* != */
%token          _DAMP       /* && */
%token          _LPAREN     /* ( */
%token          _RPAREN     /* ) */
%token          _STAR       /* * */
%token          _PLUS       /* + */
%token          _DPLUS      /* ++ */
%token          _COMMA      /* , */
%token          _MINUS      /* - */
%token          _DMINUS     /* -- */
%token          _DOT        /* . */
%token          _SLASH      /* / */
%token          _COLON      /* : */
%token          _SEMI       /* ; */
%token          _LT         /* < */
%token          _LDARROW    /* <= */
%token          _SYMB_14    /* <=> */
%token          _EQ         /* = */
%token          _DEQ        /* == */
%token          _GT         /* > */
%token          _GTEQ       /* >= */
%token          _QUESTION   /* ? */
%token          _KW_bool    /* bool */
%token          _KW_do      /* do */
%token          _KW_double  /* double */
%token          _KW_else    /* else */
%token          _KW_false   /* false */
%token          _KW_for     /* for */
%token          _KW_if      /* if */
%token          _KW_int     /* int */
%token          _KW_return  /* return */
%token          _KW_struct  /* struct */
%token          _KW_true    /* true */
%token          _KW_void    /* void */
%token          _KW_while   /* while */
%token          _LBRACE     /* { */
%token          _DBAR       /* || */
%token          _RBRACE     /* } */
%token<_string> T_Id        /* Id */
%token<_int>    _INTEGER_
%token<_double> _DOUBLE_

%type <program_> Program
%type <def_> Def
%type <listdef_> ListDef
%type <field_> Field
%type <listfield_> ListField
%type <arg_> Arg
%type <listarg_> ListArg
%type <stm_> Stm
%type <liststm_> ListStm
%type <idin_> IdIn
%type <listidin_> ListIdIn
%type <exp_> Exp15
%type <exp_> Exp14
%type <exp_> Exp13
%type <exp_> Exp12
%type <exp_> Exp11
%type <exp_> Exp10
%type <exp_> Exp9
%type <exp_> Exp8
%type <exp_> Exp4
%type <exp_> Exp3
%type <exp_> Exp2
%type <exp_> Exp
%type <exp_> Exp1
%type <exp_> Exp5
%type <exp_> Exp6
%type <exp_> Exp7
%type <listexp_> ListExp
%type <type_> Type
%type <listid_> ListId

%start Program

%%

Program : ListDef { $$ = new PDefs($1); result->program_ = $$; }
;
Def : Type T_Id _LPAREN ListArg _RPAREN _LBRACE ListStm _RBRACE { std::reverse($4->begin(),$4->end()) ;$$ = new DFun($1, $2, $4, $7); result->def_ = $$; }
  | _KW_struct T_Id _LBRACE ListField _RBRACE _SEMI { std::reverse($4->begin(),$4->end()) ;$$ = new DStruct($2, $4); result->def_ = $$; }
;
ListDef : /* empty */ { $$ = new ListDef(); result->listdef_ = $$; }
  | ListDef Def { $1->push_back($2); $$ = $1; result->listdef_ = $$; }
;
Field : Type T_Id { $$ = new FDecl($1, $2); result->field_ = $$; }
;
ListField : Field _SEMI { $$ = new ListField(); $$->push_back($1); result->listfield_ = $$; }
  | Field _SEMI ListField { $3->push_back($1); $$ = $3; result->listfield_ = $$; }
;
Arg : Type T_Id { $$ = new ADecl($1, $2); result->arg_ = $$; }
;
ListArg : /* empty */ { $$ = new ListArg(); result->listarg_ = $$; }
  | Arg { $$ = new ListArg(); $$->push_back($1); result->listarg_ = $$; }
  | Arg _COMMA ListArg { $3->push_back($1); $$ = $3; result->listarg_ = $$; }
;
Stm : Exp _SEMI { $$ = new SExp($1); result->stm_ = $$; }
  | Type ListIdIn _SEMI { std::reverse($2->begin(),$2->end()) ;$$ = new SDecls($1, $2); result->stm_ = $$; }
  | _KW_return Exp _SEMI { $$ = new SReturn($2); result->stm_ = $$; }
  | _KW_return _SEMI { $$ = new SReturnV(); result->stm_ = $$; }
  | _KW_while _LPAREN Exp _RPAREN Stm { $$ = new SWhile($3, $5); result->stm_ = $$; }
  | _KW_do Stm _KW_while _LPAREN Exp _RPAREN _SEMI { $$ = new SDoWhile($2, $5); result->stm_ = $$; }
  | _KW_for _LPAREN Exp _SEMI Exp _SEMI Exp _RPAREN Stm { $$ = new SFor($3, $5, $7, $9); result->stm_ = $$; }
  | _LBRACE ListStm _RBRACE { $$ = new SBlock($2); result->stm_ = $$; }
  | _KW_if _LPAREN Exp _RPAREN Stm _KW_else Stm { $$ = new SIfElse($3, $5, $7); result->stm_ = $$; }
;
ListStm : /* empty */ { $$ = new ListStm(); result->liststm_ = $$; }
  | ListStm Stm { $1->push_back($2); $$ = $1; result->liststm_ = $$; }
;
IdIn : T_Id { $$ = new IdNoInit($1); result->idin_ = $$; }
  | T_Id _EQ Exp { $$ = new IdInit($1, $3); result->idin_ = $$; }
;
ListIdIn : IdIn { $$ = new ListIdIn(); $$->push_back($1); result->listidin_ = $$; }
  | IdIn _COMMA ListIdIn { $3->push_back($1); $$ = $3; result->listidin_ = $$; }
;
Exp15 : _KW_true { $$ = new ETrue(); result->exp_ = $$; }
  | _KW_false { $$ = new EFalse(); result->exp_ = $$; }
  | _INTEGER_ { $$ = new EInt($1); result->exp_ = $$; }
  | _DOUBLE_ { $$ = new EDouble($1); result->exp_ = $$; }
  | T_Id { $$ = new EId($1); result->exp_ = $$; }
  | _LPAREN Exp _RPAREN { $$ = $2; result->exp_ = $$; }
;
Exp14 : T_Id _LPAREN ListExp _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new EApp($1, $3); result->exp_ = $$; }
  | Exp14 _DOT T_Id { $$ = new EProj($1, $3); result->exp_ = $$; }
  | Exp14 _DPLUS { $$ = new EPIncr($1); result->exp_ = $$; }
  | Exp14 _DMINUS { $$ = new EPDecr($1); result->exp_ = $$; }
  | Exp15 { $$ = $1; result->exp_ = $$; }
;
Exp13 : _DPLUS Exp13 { $$ = new EIncr($2); result->exp_ = $$; }
  | _DMINUS Exp13 { $$ = new EDecr($2); result->exp_ = $$; }
  | _PLUS Exp13 { $$ = new EUPlus($2); result->exp_ = $$; }
  | _MINUS Exp13 { $$ = new EUMinus($2); result->exp_ = $$; }
  | Exp14 { $$ = $1; result->exp_ = $$; }
;
Exp12 : Exp12 _STAR Exp13 { $$ = new ETimes($1, $3); result->exp_ = $$; }
  | Exp12 _SLASH Exp13 { $$ = new EDiv($1, $3); result->exp_ = $$; }
  | Exp13 { $$ = $1; result->exp_ = $$; }
;
Exp11 : Exp11 _PLUS Exp12 { $$ = new EPlus($1, $3); result->exp_ = $$; }
  | Exp11 _MINUS Exp12 { $$ = new EMinus($1, $3); result->exp_ = $$; }
  | Exp12 { $$ = $1; result->exp_ = $$; }
;
Exp10 : Exp10 _SYMB_14 Exp11 { $$ = new ETwc($1, $3); result->exp_ = $$; }
  | Exp11 { $$ = $1; result->exp_ = $$; }
;
Exp9 : Exp9 _LT Exp10 { $$ = new ELt($1, $3); result->exp_ = $$; }
  | Exp9 _GT Exp10 { $$ = new EGt($1, $3); result->exp_ = $$; }
  | Exp9 _LDARROW Exp10 { $$ = new ELtEq($1, $3); result->exp_ = $$; }
  | Exp9 _GTEQ Exp10 { $$ = new EGtEq($1, $3); result->exp_ = $$; }
  | Exp10 { $$ = $1; result->exp_ = $$; }
;
Exp8 : Exp8 _DEQ Exp9 { $$ = new EEq($1, $3); result->exp_ = $$; }
  | Exp8 _BANGEQ Exp9 { $$ = new ENEq($1, $3); result->exp_ = $$; }
  | Exp9 { $$ = $1; result->exp_ = $$; }
;
Exp4 : Exp4 _DAMP Exp5 { $$ = new EAnd($1, $3); result->exp_ = $$; }
  | Exp5 { $$ = $1; result->exp_ = $$; }
;
Exp3 : Exp3 _DBAR Exp4 { $$ = new EOr($1, $3); result->exp_ = $$; }
  | Exp4 { $$ = $1; result->exp_ = $$; }
;
Exp2 : Exp3 _EQ Exp2 { $$ = new EAss($1, $3); result->exp_ = $$; }
  | Exp3 _QUESTION Exp _COLON Exp2 { $$ = new ECond($1, $3, $5); result->exp_ = $$; }
  | Exp3 { $$ = $1; result->exp_ = $$; }
;
Exp : Exp1 { $$ = $1; result->exp_ = $$; }
;
Exp1 : Exp2 { $$ = $1; result->exp_ = $$; }
;
Exp5 : Exp6 { $$ = $1; result->exp_ = $$; }
;
Exp6 : Exp7 { $$ = $1; result->exp_ = $$; }
;
Exp7 : Exp8 { $$ = $1; result->exp_ = $$; }
;
ListExp : /* empty */ { $$ = new ListExp(); result->listexp_ = $$; }
  | Exp { $$ = new ListExp(); $$->push_back($1); result->listexp_ = $$; }
  | Exp _COMMA ListExp { $3->push_back($1); $$ = $3; result->listexp_ = $$; }
;
Type : _KW_bool { $$ = new Type_bool(); result->type_ = $$; }
  | _KW_int { $$ = new Type_int(); result->type_ = $$; }
  | _KW_double { $$ = new Type_double(); result->type_ = $$; }
  | _KW_void { $$ = new Type_void(); result->type_ = $$; }
  | T_Id { $$ = new TypeId($1); result->type_ = $$; }
;
ListId : T_Id { $$ = new ListId(); $$->push_back($1); result->listid_ = $$; }
  | T_Id _COMMA ListId { $3->push_back($1); $$ = $3; result->listid_ = $$; }
;

%%


/* Entrypoint: parse Program* from file. */
Program* pProgram(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Program* from string. */
Program* psProgram(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Def* from file. */
Def* pDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.def_;
  }
}

/* Entrypoint: parse Def* from string. */
Def* psDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.def_;
  }
}

/* Entrypoint: parse ListDef* from file. */
ListDef* pListDef(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listdef_;
  }
}

/* Entrypoint: parse ListDef* from string. */
ListDef* psListDef(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listdef_;
  }
}

/* Entrypoint: parse Field* from file. */
Field* pField(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.field_;
  }
}

/* Entrypoint: parse Field* from string. */
Field* psField(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.field_;
  }
}

/* Entrypoint: parse ListField* from file. */
ListField* pListField(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfield_->begin(), result.listfield_->end());
    return result.listfield_;
  }
}

/* Entrypoint: parse ListField* from string. */
ListField* psListField(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listfield_->begin(), result.listfield_->end());
    return result.listfield_;
  }
}

/* Entrypoint: parse Arg* from file. */
Arg* pArg(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arg_;
  }
}

/* Entrypoint: parse Arg* from string. */
Arg* psArg(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.arg_;
  }
}

/* Entrypoint: parse ListArg* from file. */
ListArg* pListArg(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listarg_->begin(), result.listarg_->end());
    return result.listarg_;
  }
}

/* Entrypoint: parse ListArg* from string. */
ListArg* psListArg(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listarg_->begin(), result.listarg_->end());
    return result.listarg_;
  }
}

/* Entrypoint: parse Stm* from file. */
Stm* pStm(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stm_;
  }
}

/* Entrypoint: parse Stm* from string. */
Stm* psStm(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.stm_;
  }
}

/* Entrypoint: parse ListStm* from file. */
ListStm* pListStm(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.liststm_;
  }
}

/* Entrypoint: parse ListStm* from string. */
ListStm* psListStm(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.liststm_;
  }
}

/* Entrypoint: parse IdIn* from file. */
IdIn* pIdIn(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idin_;
  }
}

/* Entrypoint: parse IdIn* from string. */
IdIn* psIdIn(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.idin_;
  }
}

/* Entrypoint: parse ListIdIn* from file. */
ListIdIn* pListIdIn(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listidin_->begin(), result.listidin_->end());
    return result.listidin_;
  }
}

/* Entrypoint: parse ListIdIn* from string. */
ListIdIn* psListIdIn(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listidin_->begin(), result.listidin_->end());
    return result.listidin_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp15(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp15(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp14(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp14(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp13(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp13(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp12(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp12(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp11(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp11(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp10(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp10(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp8(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp8(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from file. */
Exp* pExp7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse Exp* from string. */
Exp* psExp7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.exp_;
  }
}

/* Entrypoint: parse ListExp* from file. */
ListExp* pListExp(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexp_->begin(), result.listexp_->end());
    return result.listexp_;
  }
}

/* Entrypoint: parse ListExp* from string. */
ListExp* psListExp(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexp_->begin(), result.listexp_->end());
    return result.listexp_;
  }
}

/* Entrypoint: parse Type* from file. */
Type* pType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from string. */
Type* psType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse ListId* from file. */
ListId* pListId(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listid_->begin(), result.listid_->end());
    return result.listid_;
  }
}

/* Entrypoint: parse ListId* from string. */
ListId* psListId(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = cpp__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = cpp__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  cpp__delete_buffer(buf, scanner);
  cpp_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listid_->begin(), result.listid_->end());
    return result.listid_;
  }
}



